참고 링크 : [신입 개발자 기술면접 질문 정리 - 데이터베이스 — 슬기로운 개발생활](https://dev-coco.tistory.com/158#%F-%-F%--%A-%C-%A-%EB%-D%B-%EC%-D%B-%ED%--%B-%EB%B-%A-%EC%-D%B-%EC%-A%A-%EC%-D%--%--%ED%-A%B-%EC%A-%--%EC%--%--%--%EB%-C%--%ED%--%B-%--%EC%--%A-%EB%AA%--%ED%--%B-%EC%A-%BC%EC%--%B-%EC%-A%---)

### **💡** **데이터베이스의 특징에 대해 설명해주세요.**

1. 실시간 접근성 (Real-Time Accessibility) : 비정형적인 질의(조회)에 대하여 실시간 처리에 의한 응답이 가능해야 한다.

2. 지속적인 변화 (Continuous Evolution) : 데이터베이스의 상태는 동적이다. 즉, 새로운 데이터의 삽입, 삭제, 갱신으로 항상 최신의 데이터를 유지해야 한다.

3. 동시 공용 (Concurrent Sharing) : 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로 다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 한다.

4. 내용에 의한 참조 (Content Reference) : 데이터베이스에 있는 데이터를 참조할 때 데이터 레코드의 주소나 위치에 의해서가 아니라 사용자가 요구하는 데이터 내용으로 찾는다.

### **💡** **데이터베이스 언어(DDL, DML, DCL)에 대해 설명해주세요.**

* DDL (Data Definition Language)
  
  * 데이터 베이스 구조를 정의, 수정, 삭제하는 언어
  
  * alter, create, drop

* DML (Data Manipulation Language)
  
  * 데이터베이스 내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어
  
  * select, insert, update, delete

* DCL (Data Control Language)
  
  * 데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어
  
  * commit, rollback, grant, revoke

### **💡** **SELECT 쿼리의 수행 순서를 알려주세요.**

💎 **SQL 문법 순서**

- **SELECT**
- **FROM**
- **WHERE**
- **GROUP BY**
- **HAVING**
- **ORDER BY**

💎 **SQL 실제 실행 순서**

- **FROM** : 각 테이블 확인
- **ON** : 조인 조건 확인
- **JOIN** : 테이블 조인 (병합)
- **WHERE** : 데이터 추출 조건 확인
- **GROUP BY** : 특정 칼럼으로 데이터 그룹화
- **HAVING** : 그룹화 이후 데이터 추출 조건 확인
- **SELECT** : 데이터 추출
- **DISTINCT** : 중복 제거
- **ORDER BY** : 데이터 정렬

실행 작동 순서를 자주 사용하는 쿼리문만 설명하면 다음과 같은 순서로 이루어진다.

1. 조회 테이블 확인 (FROM)

2. 데이터 추출 조건 확인 (WHERE)

3. 컬럼 그룹화 (GROUP BY)

4. 그룹화 조건 (HAVING)

5. 데이터 추출 (SELECT)

6. 데이터 순서 정렬 (ORDER BY) 

### **💡** **Index에 대해 설명해주시고, 장/단점에 대해 아는대로 말해주세요.**

추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

![](https://blog.kakaocdn.net/dn/cBQD97/btqKRtpm2pl/rmo7jTbiiE9tsSQsUg0JPK/img.png)

#### 인덱스를 사용하면 좋은 경우

* 규모가 작지 않은 테이블

* INSERT, UPDATE, DELETE 가 자주 발생하지 않는 컬럼

* JOIN 이나 WHERE 또는 ODDER BY 에 자주 사용되는 컬럼

* 데이터의 중복도가 낮은 컬럼

인덱스를 사용하는 것 만큼이나 생성된 인덱스를 관리해주는 것도 중요하다. 그러므로 사용되지 않는 인덱스는 바로 제거를 해주어야 한다.

인덱스는 결국 지정한 컬럼을 기준으로 메모리 영역에 일종의 목차를 생성하는 것

insert, update, delete의 성능을 희생하고 대신 select 의 성능을 향상시킨다.

[주의] update, delete 행위가 느린것이지 update, delete 를 하기위해 해당 데이터를 조회하는 것은 인덱스가 있으면 빠르게 조회가 된다.

**💡** **그렇다면 DBMS는 Index를 어떻게 관리하고 있나요? (Index 자료구조)**

대부분의 RDBMS 구현체들은 기본적으로 B-Tree 인덱스를 사용한다. 해시 테이블을 사용하기도 한다.

B-tree는 트리 자료구조의 일종으로 이진트리를 확장해 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다.

### **💡** **정규화에 대해 설명해주세요.**

정규화는 하나의 릴레이션(=테이블) 에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이다.

* 정규화의 목적
  
  * 불필요한 데이터를 제거해 중복을 최소화 한다
  
  * 삽입/갱신/삭제 시 발생할 수 있는 각종 이상 현상 (Anomaly) 을 방지한다.

#### 제 1 정규형

테이블의 컬럼이 원자값(Atomic Value)을 갖도록 분해한다.

#### 제 2 정규형

제 1 정규형을 만족하고, 기본키가 아닌 속성이 기본키에 **완전 함수 종속**이도록 분해한다.

* 완전 함수 종속 : 기본키의 부분집합이 다른 값을 결정하지 않는 것

#### 제 3 정규형

제 2 정규형을 만족하고, **이행적 함수 종속**을 없애도록 분해한다.

* 이행적 함수 종속 : A->B, B->C 가 성립할 때, A->C 가 성립되는 것을 의미

#### BCNF 정규형

제 3 정규형을 만족하고, 함수 종속성 X -> Y 가 성립할 때 모든 결정자 X가 후보키가 되도록 분해한다.

**💡** **정규화에는 어떤 장점이 있고 어떤 단점이 있는지 아는대로 설명해주세요.**

* 장점
  
  * 데이터베이스 변경 시 이상 현상이 발생하는 문제점을 해결할 수 있다.
  
  * 데이터베이스 구조 확장 시 정규화 된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.

* 단점
  
  * 릴레이션의 분해로 인해 join 연산이 많아진다. 이로 인해 질의에 의한 응답시간이 느려질 수 있다.

**💡 역정규화를 하는 이유에 대해 아는대로 설명해주세요.**

정규화를 거치면 릴레이션 간의 연산 (join) 이 많아지는데, 이로 인해 성능이 저하될 우려가 있다. 역정규화를 하는 가장 큰 이유는 성능 문제가 있는 (읽기 작업이 많이 필요한) DB 전반적인 성능을 향상시키기 위함이다.

### **💡** **이상 현상의 종류에 대해 설명해주세요.**

* 테이블을 설계할 때 잘못 설계하여 데이터를 삽입, 삭제, 수정할 때 생기는 논리적 오류
  
  1. 삽입 이상(Insertion Anomaly) : 자료를 삽입할 때 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 상황
  
  2. 갱신 이상(Modification ANomaly) : 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상
  
  3. 삭제 이상(Deletion Anomaly) : 어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상

* 이러한 이상 현상을 예방하고 효과적인 연산을 하기 위해 데이터 정규화를 한다.

### **💡** **SQL Injection이 무엇인지 설명해주세요.**

SQL Injection 이란 공격자가 악의적인 의도를 갖는 SQL 구문을 삽입하여 데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 기법이다.

**💡** **SQL Injection을 방어 및 방지하기 위한 방법에 대해 알고 있다면 설명해주세요.**

1. 입력값을 검증하여 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우에 입력된 값이 개발자가 의도한 값(유효값)인지 검증한다.

2. 저장 프로시저를 사용한다.
   
   - 사용하고자 하는 Query 에 미리 형식을 지정하는 것을 말한다.  지정된 형식의 데이터가 아니면 Query가 실행되지 않기 때문에 보안성이 크게 향상한다.
   
   - 저장 프로시저는 쿼리문의 집합으로, 어떤 동작을 여러 쿼리를 거쳐서 일괄적으로 처리할 때 사용한다.

### **💡** RDBMS와 NoSQL의 차이에 대해 설명해주세요.

RDBMS 는 모든 데이터를 2차원 테이블 형태로 표현한다.

* 장점 : 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.

* 단점 : 시스템이 커질수록 쿼리가 복잡해지고 성능이 저하된다.

NoSQL(Not Only SQL) 은 RDBMS 와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리한다.

* 장점 : 스키마없이 key-value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다.

* 단점 : 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 한다.

**💡** **그렇다면 RDBMS와 NoSQL은 어느 경우에 적합한가요?**

* RDBMS 는 데이터 구조가 명확하고, 변경될 여지가 없으며 스키마가 중요한 경우 사용하는 것이 좋다. 또한 중복된 데이터가 없어 (데이터 무결성) 변경이 용이하기 때문에 관계를 맺고 있는 데이터가 자주 변경이 이루어지는 시스템에 적합하다.

* NoSQL은 정확한 데이터 구조를 알 수 없고, 데이터가 변경/확장 될 수 있는 경우 사용하는 것이 좋다. 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경될 시 모든 컬렉션에서 수정해야 하기 때문에 Update 가 많이 이루어지지 않는 시스템에 좋다.

### **💡** **트랜잭션이란 무엇인지 설명해주세요.**

* 트랜잭션은 <u>작업의 완전성</u>을 보장해준다.

* 즉, 작업을 모두 처리하고나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능

* 하나의 트랜잭션은 Commit(작업 완료) 되거나 Rollback (취소) 된다.

**💡** **트랜잭션의 특성(ACID)에 대해 설명해주세요.**

1. 원자성 (Atomicity) : 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다.

2. 일관성 (Consistency) : 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.

3. 독립성 (Isolation) : 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.

4. 영속성 (Durability) : 완료된 결과는 영구적으로 반영되어야 한다.

### **💡** **DB 락에 대해 설명해주세요.**

DB lock 은 트랜잭션 처리의 순차성을 보장하기 위한 방법이다.

* 공유락(Shared Lock) 은 트랜잭션이 읽기를 할때 사용하는 락이며, 데이터를 읽기만 하기 때문에 같은 공유락끼리는 동시에 접근이 가능하다.

* 베타락(Exclusive Lock) 은 데이터를 변경할 때 사용하는 락이다. 트랜잭션이 완료될때까지 유지되며, 베타락이 끝나기 전까지 어떠한 접근도 허용하지 않는다.

### **💡 Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해주세요.**

RDBMS 는 단순 텍스트 매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능하다.

엘라스틱 서치는 동의어나 유의어를 활용한 검색이 가능하며, 비정형 데이터의 색인과 검색이 가능하고, 역색인 지원으로 매우 빠른 검색이 가능하다.

엘라스틱 서치는 NoSQL 의 일종으로 분류할 수 있고, 분산처리를 통해 실시간성으로 빠른 검색이 가능하다. 기본적으로 검색 엔진이지만 MongoDB나 Hbase 같은 대용량 스토리지로도 활용이 가능하다.

#### ES 장점

* 오픈소스 검색엔진

* RESTful API

* 역색인

* Document-Oriented : 여러 계층 구조의 문서로도 저장이 가능하며, 계층 구조로 된 문서도 한번의 쿼리로 쉽게 조회할 수 있다.

#### ES 단점

* 완전 실시간은 아니다.
  
  * 내부적으로 commit 과 flush 같은 복잡한 과정을 거치기 때문

* transaction rollback을 지원하지 않는다.
  
  * 전체적인 클러스터의 성능 향상을 위해 시스템적으로 비용 소모가 큰 롤백과 트랜잭션은 지원하지 않는다.

* 데이터의 업데이트를 제공하지 않는다.
  
  * 업데이트 명령이 올 결우 기존 문서를 삭제하고 새로운 문서를 생성한다.

### **💡 옵티마이저(Optimizer)에 대해 아는대로 말해주세요.**

 <u>SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심 엔진</u>이다.

컴퓨터의 두뇌가 CPU 인 것 처럼 DBMS 의 두뇌는 옵티마이저라고 할 수 있다.

개발자가 SQL을 작성하고 실행하면 즉시 실행되는 것이 아니라 옵티마이저라는 곳에서 "이 쿼리문을 어떻게 실행시키겠다" 라는 여러가지 실행 계획을 세우고, 최고의 효율을 갖는 실행 계획을 판별한 후, 그 실행 계획에 따라 쿼리를 수행하게 되는 것이다.

### **💡 DB 튜닝(Tuning)이 무엇인지 그리고 튜닝의 3단계에 대해 설명해주세요.**

* DB 튜닝이란 DB의 구조나, DB 자체, 운영체제 등을 조정하여 DB 시스템의 전체적인 성능을 개선하는 작업을 말한다.

* DB 설계 튜닝 -> DBMS 튜닝 -> SQL 튜닝 단계로 진행할 수 있다.

* 1단계 : DB 설계 튜닝 (모델링 관점)
  
  * DB 설계 단계에서 성능을 고려하여 설계
  
  * 데이터 모델링, 인덱스 설계
  
  * 데이터 파일, 테이블 스페이스 설계
  
  * 데이터베이스 용량 산정
  
  * 튜닝 사례 - 반정규화, 분산파일 배치

* 2단계 : DBMS 튜닝 (환경 관점)
  
  * 성능을 고려하여 메모리나 블록 크기 지정
  
  * CPU, 메모리 I/O 에 관한 관점
  
  * 튜닝 사례 - buffer 크기, Cache 크기

* 3단계 : SQL 튜닝 (APP 관점)
  
  * SQL 작성 시 성능 고려
  
  * Join, Indexing, SQL Execution Plan
  
  * 튜닝 사례 - Hash/Join

### **💡 inner join과 outer join의 차이를 설명해주세요.**

inner join 은 서로 연관된 내용만 검색하는 조인 방법 (교집합)

outer join 은 데이터가 있는 쪽의 내용을 전부 출력하는 방법 (합집합)

- LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN이 있다.

### **💡** group by의 역할에 대해 설명해주세요.

특정 컬럼을 기준으로 연산한 결과를 집계 키로 정의하여 그룹을 짓는 역할

집합 연산자는 COUNT, SUM, AVG, MAX, MIN 등이 있고, DICTINCT 와 같이 중복 데이터를 제거하는 특징이 있다.

### **💡 DELETE, TRUNCATE, DROP의 차이를 설명해주세요.**

* DELETE : 데이터는 지우지만 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 수 있다. 삭제 후 되돌릴 수 있다.

* TRUNCATE : 전체 데이터를 한번에 삭제하는 방식, 테이블 용량이 줄어들고 인덱스 등도 삭제되지만 테이블은 삭제할 수 없고, 삭제 후 되돌릴 수 없다.

* DROP : 테이블 자체를 완전히 삭제하는 방식 (공간, 인덱스, 객체 모두 삭제), 삭제 후 되돌릴 수 없다.

### **💡 ORM에 대해 설명해주세요.**

 Object-Relational Mapping

객체와 관계형 데이터베이스 매핑의 줄임말이다.

OOP 에서 쓰는 객체라는 개념을 구현한 클래스와 RDB에서 쓰이는 데이터인 테이블을 연결하는 것을 의미한다.

ORM을 이용하면 따로 SQL 문을 작성할 필요 없이 객체를 통해 간접적으로 데이터베이스를 조작할 수 있게된다.

#### ORM 프레임워크

* JPA/Hibernate
  
  * JPA는 자바의 ORM 기술 표준으로 인터페이스의 모음이다.
  
  * 이러한 JPA 표준 명세를 구현한 구현체가 바로 Hibernate이다.

* Django ORM
  
  * python 기반 프레임워크인 Django 에서 자체적으로 지원하는 ORM 이다.

### **💡** HAVING과 WHERE의 차이를 설명해주세요.

HAVING 은 그룹을 필터링하는데 사용되고, WHERE 은 개별 행을 필터링하는데 사용된다.

집계 함수는 HAVING 절과 함께 사용할 수 있지만, WHERE 절은 사용이 불가능하다.

(집계함수를 사용할 수 있는 GROUP BY 절보다 WHERE 절이 먼저 수행되기 때문)

having 은 그룹화 또는 집계가 발생한 후 필터링하는데 사용되고,

where 은 그룹화 또는 집계가 발생하기 전에 필터링하는데 사용된다.

### **💡 JOIN에서 ON과 WHERE의 차이를 설명해주세요.**

ON 이 WHERE 보다 먼저 실행되어 JOIN 을 하기 전에 필터링을 하고

(= ON 조건으로 필터링이 된 레코드들 간 JOIN이 이루어진다.)

WHERE 은 JOIN 을 한 후에 필터링을 한다.

(= JOIN 을 한 결과에서 WHERE 조건절로 필터링이 이루어진다.)
